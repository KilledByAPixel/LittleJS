"use strict";let showWatermark=0;let godMode=0;let debugKeyCode=0;const debug=0;const debugOverlay=0;const debugPhysics=0;const debugParticles=0;const debugRaycast=0;const debugGamepads=0;const debugMedals=0;const ASSERT=()=>{};const debugInit=()=>{};const debugUpdate=()=>{};const debugRender=()=>{};const debugRect=()=>{};const debugCircle=()=>{};const debugPoint=()=>{};const debugLine=()=>{};const debugAABB=()=>{};const debugText=()=>{};const debugClear=()=>{};const debugSaveCanvas=()=>{};"use strict";const PI=Math.PI;const abs=a=>a<0?-a:a;const min=(a,b)=>a<b?a:b;const max=(a,b)=>a>b?a:b;const sign=a=>a<0?-1:1;const mod=(a,b=1)=>(a%b+b)%b;const clamp=(v,min=0,max=1)=>v<min?min:v>max?max:v;const percent=(v,min=0,max=1)=>max-min?clamp((v-min)/(max-min)):0;const lerp=(p,min=0,max=1)=>min+clamp(p)*(max-min);const smoothStep=p=>p*p*(3-2*p);const nearestPowerOfTwo=v=>2**Math.ceil(Math.log2(v));const isOverlapping=(pA,sA,pB,sB)=>abs(pA.x-pB.x)*2<sA.x+sB.x&&abs(pA.y-pB.y)*2<sA.y+sB.y;const wave=(frequency=1,amplitude=1,t=time)=>amplitude/2*(1-Math.cos(t*frequency*2*PI));const formatTime=t=>(t/60|0)+":"+(t%60<10?"0":"")+(t%60|0);const rand=(a=1,b=0)=>b+(a-b)*Math.random();const randInt=(a=1,b=0)=>rand(a,b)|0;const randSign=()=>randInt(2)*2-1;const randInCircle=(radius=1,minRadius=0)=>radius>0?randVector(radius*rand(minRadius/radius,1)**.5):new Vector2;const randVector=(length=1)=>(new Vector2).setAngle(rand(2*PI),length);const randColor=(cA=new Color,cB=new Color(0,0,0,1),linear)=>linear?cA.lerp(cB,rand()):new Color(rand(cA.r,cB.r),rand(cA.g,cB.g),rand(cA.b,cB.b),rand(cA.a,cB.a));let randSeed=1;const setRandSeed=seed=>randSeed=seed;const randSeeded=(a=1,b=0)=>{randSeed^=randSeed<<13;randSeed^=randSeed>>>17;randSeed^=randSeed<<5;return b+(a-b)*abs(randSeed%1e9)/1e9};const vec2=(x=0,y)=>x.x==undefined?new Vector2(x,y==undefined?x:y):new Vector2(x.x,x.y);const isVector2=v=>!isNaN(v.x)&&!isNaN(v.y);class Vector2{constructor(x=0,y=0){this.x=x;this.y=y}copy(){return new Vector2(this.x,this.y)}add(v){ASSERT(isVector2(v));return new Vector2(this.x+v.x,this.y+v.y)}subtract(v){ASSERT(isVector2(v));return new Vector2(this.x-v.x,this.y-v.y)}multiply(v){ASSERT(isVector2(v));return new Vector2(this.x*v.x,this.y*v.y)}divide(v){ASSERT(isVector2(v));return new Vector2(this.x/v.x,this.y/v.y)}scale(s){ASSERT(!isVector2(s));return new Vector2(this.x*s,this.y*s)}length(){return this.lengthSquared()**.5}lengthSquared(){return this.x**2+this.y**2}distance(v){return this.distanceSquared(v)**.5}distanceSquared(v){return(this.x-v.x)**2+(this.y-v.y)**2}normalize(length=1){const l=this.length();return l?this.scale(length/l):new Vector2(0,length)}clampLength(length=1){const l=this.length();return l>length?this.scale(length/l):this}dot(v){ASSERT(isVector2(v));return this.x*v.x+this.y*v.y}cross(v){ASSERT(isVector2(v));return this.x*v.y-this.y*v.x}angle(){return Math.atan2(this.x,this.y)}setAngle(a=0,length=1){this.x=length*Math.sin(a);this.y=length*Math.cos(a);return this}rotate(a){const c=Math.cos(a),s=Math.sin(a);return new Vector2(this.x*c-this.y*s,this.x*s+this.y*c)}direction(){return abs(this.x)>abs(this.y)?this.x<0?3:1:this.y<0?2:0}invert(){return new Vector2(this.y,-this.x)}floor(){return new Vector2(Math.floor(this.x),Math.floor(this.y))}area(){return abs(this.x*this.y)}lerp(v,p){ASSERT(isVector2(v));return this.add(v.subtract(this).scale(clamp(p)))}arrayCheck(arraySize){return this.x>=0&&this.y>=0&&this.x<arraySize.x&&this.y<arraySize.y}toString(digits=3){if(debug){return`(${(this.x<0?"":" ")+this.x.toFixed(digits)},${(this.y<0?"":" ")+this.y.toFixed(digits)} )`}}}const rgb=(r,g,b,a)=>new Color(r,g,b,a);const hsl=(h,s,l,a)=>(new Color).setHSLA(h,s,l,a);class Color{constructor(r=1,g=1,b=1,a=1){this.r=r;this.g=g;this.b=b;this.a=a}copy(){return new Color(this.r,this.g,this.b,this.a)}add(c){return new Color(this.r+c.r,this.g+c.g,this.b+c.b,this.a+c.a)}subtract(c){return new Color(this.r-c.r,this.g-c.g,this.b-c.b,this.a-c.a)}multiply(c){return new Color(this.r*c.r,this.g*c.g,this.b*c.b,this.a*c.a)}divide(c){return new Color(this.r/c.r,this.g/c.g,this.b/c.b,this.a/c.a)}scale(s,a=s){return new Color(this.r*s,this.g*s,this.b*s,this.a*a)}clamp(){return new Color(clamp(this.r),clamp(this.g),clamp(this.b),clamp(this.a))}lerp(c,p){return this.add(c.subtract(this).scale(clamp(p)))}setHSLA(h=0,s=0,l=1,a=1){const q=l<.5?l*(1+s):l+s-l*s,p=2*l-q,f=(p,q,t)=>(t=(t%1+1)%1)<1/6?p+(q-p)*6*t:t<1/2?q:t<2/3?p+(q-p)*(2/3-t)*6:p;this.r=f(p,q,h+1/3);this.g=f(p,q,h);this.b=f(p,q,h-1/3);this.a=a;return this}getHSLA(){const r=clamp(this.r);const g=clamp(this.g);const b=clamp(this.b);const a=clamp(this.a);const max=Math.max(r,g,b);const min=Math.min(r,g,b);const l=(max+min)/2;let h=0,s=0;if(max!=min){let d=max-min;s=l>.5?d/(2-max-min):d/(max+min);if(r==max)h=(g-b)/d+(g<b?6:0);else if(g==max)h=(b-r)/d+2;else if(b==max)h=(r-g)/d+4}return[h/6,s,l,a]}mutate(amount=.05,alphaAmount=0){return new Color(this.r+rand(amount,-amount),this.g+rand(amount,-amount),this.b+rand(amount,-amount),this.a+rand(alphaAmount,-alphaAmount)).clamp()}toString(useAlpha=1){const toHex=c=>((c=c*255|0)<16?"0":"")+c.toString(16);return"#"+toHex(this.r)+toHex(this.g)+toHex(this.b)+(useAlpha?toHex(this.a):"")}setHex(hex){const fromHex=c=>clamp(parseInt(hex.slice(c,c+2),16)/255);this.r=fromHex(1);this.g=fromHex(3),this.b=fromHex(5);this.a=hex.length>7?fromHex(7):1;return this}rgbaInt(){const toByte=c=>clamp(c)*255|0;const r=toByte(this.r);const g=toByte(this.g)<<8;const b=toByte(this.b)<<16;const a=toByte(this.a)<<24;return r+g+b+a}}class Timer{constructor(timeLeft){this.time=timeLeft==undefined?undefined:time+timeLeft;this.setTime=timeLeft}set(timeLeft=0){this.time=time+timeLeft;this.setTime=timeLeft}unset(){this.time=undefined}isSet(){return this.time!=undefined}active(){return time<=this.time}elapsed(){return time>this.time}get(){return this.isSet()?time-this.time:0}getPercent(){return this.isSet()?percent(this.time-time,this.setTime,0):0}toString(){if(debug){return this.unset()?"unset":Math.abs(this.get())+" seconds "+(this.get()<0?"before":"after")}}valueOf(){return this.get()}}"use strict";let cameraPos=vec2();let cameraScale=32;let canvasMaxSize=vec2(1920,1200);let canvasFixedSize=vec2();let cavasPixelated=1;let fontDefault="arial";let glEnable=1;let glOverlay=1;let tileSizeDefault=vec2(16);let tileFixBleedScale=.3;let enablePhysicsSolver=1;let objectDefaultMass=1;let objectDefaultDamping=1;let objectDefaultAngleDamping=1;let objectDefaultElasticity=0;let objectDefaultFriction=.8;let objectMaxSpeed=1;let gravity=0;let particleEmitRateScale=1;let gamepadsEnable=1;let gamepadDirectionEmulateStick=1;let inputWASDEmulateDirection=1;let touchGamepadEnable=0;let touchGamepadAnalog=1;let touchGamepadSize=99;let touchGamepadAlpha=.3;let vibrateEnable=1;let soundEnable=1;let soundVolume=.5;let soundDefaultRange=40;let soundDefaultTaper=.7;let medalDisplayTime=5;let medalDisplaySlideTime=.5;let medalDisplaySize=vec2(640,80);let medalDisplayIconSize=50;let medalsPreventUnlock;"use strict";const engineName="LittleJS";const engineVersion="1.6.4";const frameRate=60;const timeDelta=1/frameRate;let engineObjects=[];let engineObjectsCollide=[];let frame=0;let time=0;let timeReal=0;let paused=0;function setPaused(_paused){paused=_paused}function engineInit(gameInit,gameUpdate,gameUpdatePost,gameRender,gameRenderPost,tileImageSource){tileImage.onerror=tileImage.onload=()=>{tileImageFixBleed=vec2(tileFixBleedScale).divide(tileImageSize=vec2(tileImage.width,tileImage.height));debug&&(tileImage.onload=()=>ASSERT(1));const styleBody="margin:0;overflow:hidden;background:#000"+";touch-action:none"+";user-select:none"+";-webkit-user-select:none";document.body.style=styleBody;document.body.appendChild(mainCanvas=document.createElement("canvas"));mainContext=mainCanvas.getContext("2d");debugInit();glEnable&&glInit();document.body.appendChild(overlayCanvas=document.createElement("canvas"));overlayContext=overlayCanvas.getContext("2d");const styleCanvas="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)";(glCanvas||mainCanvas).style=mainCanvas.style=overlayCanvas.style=styleCanvas;gameInit();engineUpdate()};let frameTimeLastMS=0,frameTimeBufferMS,averageFPS;function engineUpdate(frameTimeMS=0){let frameTimeDeltaMS=frameTimeMS-frameTimeLastMS;frameTimeLastMS=frameTimeMS;if(debug||showWatermark)averageFPS=lerp(.05,averageFPS,1e3/(frameTimeDeltaMS||1));const debugSpeedUp=debug&&keyIsDown(107);const debugSpeedDown=debug&&keyIsDown(109);if(debug)frameTimeDeltaMS*=debugSpeedUp?5:debugSpeedDown?.2:1;timeReal+=frameTimeDeltaMS/1e3;frameTimeBufferMS+=!paused*frameTimeDeltaMS;if(!debugSpeedUp)frameTimeBufferMS=min(frameTimeBufferMS,50);if(canvasFixedSize.x){mainCanvas.width=canvasFixedSize.x;mainCanvas.height=canvasFixedSize.y;const aspect=innerWidth/innerHeight;const fixedAspect=mainCanvas.width/mainCanvas.height;(glCanvas||mainCanvas).style.width=mainCanvas.style.width=overlayCanvas.style.width=aspect<fixedAspect?"100%":"";(glCanvas||mainCanvas).style.height=mainCanvas.style.height=overlayCanvas.style.height=aspect<fixedAspect?"":"100%"}else{mainCanvas.width=min(innerWidth,canvasMaxSize.x);mainCanvas.height=min(innerHeight,canvasMaxSize.y)}overlayCanvas.width=mainCanvas.width;overlayCanvas.height=mainCanvas.height;mainCanvasSize=vec2(mainCanvas.width,mainCanvas.height);if(paused){inputUpdate();debugUpdate();gameUpdatePost();inputUpdatePost()}else{let deltaSmooth=0;if(frameTimeBufferMS<0&&frameTimeBufferMS>-9){deltaSmooth=frameTimeBufferMS;frameTimeBufferMS=0}for(;frameTimeBufferMS>=0;frameTimeBufferMS-=1e3/frameRate){inputUpdate();gameUpdate();engineObjectsUpdate();debugUpdate();gameUpdatePost();inputUpdatePost()}frameTimeBufferMS+=deltaSmooth}enginePreRender();gameRender();engineObjects.sort((a,b)=>a.renderOrder-b.renderOrder);for(const o of engineObjects)o.destroyed||o.render();gameRenderPost();glRenderPostProcess();medalsRender();touchGamepadRender();debugRender();glEnable&&glCopyToContext(mainContext);if(showWatermark){overlayContext.textAlign="right";overlayContext.textBaseline="top";overlayContext.font="1em monospace";overlayContext.fillStyle="#000";const text=engineName+" "+"v"+engineVersion+" / "+drawCount+" / "+engineObjects.length+" / "+averageFPS.toFixed(1)+(glEnable?" GL":" 2D");overlayContext.fillText(text,mainCanvas.width-3,3);overlayContext.fillStyle="#fff";overlayContext.fillText(text,mainCanvas.width-2,2);drawCount=0}requestAnimationFrame(engineUpdate)}tileImageSource?tileImage.src=tileImageSource:tileImage.onload()}function enginePreRender(){mainCanvasSize=vec2(mainCanvas.width,mainCanvas.height);mainContext.imageSmoothingEnabled=!cavasPixelated;glEnable&&glPreRender()}function engineObjectsUpdate(){engineObjectsCollide=engineObjects.filter(o=>o.collideSolidObjects);const updateObject=o=>{if(!o.destroyed){o.update();for(const child of o.children)updateObject(child)}};for(const o of engineObjects)o.parent||updateObject(o);engineObjects=engineObjects.filter(o=>!o.destroyed);time=++frame/frameRate}function engineObjectsDestroy(){for(const o of engineObjects)o.parent||o.destroy();engineObjects=engineObjects.filter(o=>!o.destroyed)}function engineObjectsCallback(pos,size,callbackFunction,objects=engineObjects){if(!pos){for(const o of objects)callbackFunction(o)}else if(size.x!=undefined){for(const o of objects)isOverlapping(pos,size,o.pos,o.size)&&callbackFunction(o)}else{const sizeSquared=size*size;for(const o of objects)pos.distanceSquared(o.pos)<sizeSquared&&callbackFunction(o)}}"use strict";class EngineObject{constructor(pos=vec2(),size=vec2(1),tileIndex=-1,tileSize=tileSizeDefault,angle=0,color,renderOrder=0){ASSERT(isVector2(pos)&&isVector2(size));this.pos=pos.copy();this.size=size;this.drawSize;this.tileIndex=tileIndex;this.tileSize=tileSize;this.angle=angle;this.color=color;this.additiveColor;this.mass=objectDefaultMass;this.damping=objectDefaultDamping;this.angleDamping=objectDefaultAngleDamping;this.elasticity=objectDefaultElasticity;this.friction=objectDefaultFriction;this.gravityScale=1;this.renderOrder=renderOrder;this.velocity=new Vector2;this.angleVelocity=0;this.spawnTime=time;this.children=[];this.collideTiles=1;engineObjects.push(this)}update(){const parent=this.parent;if(parent){this.pos=this.localPos.multiply(vec2(parent.getMirrorSign(),1)).rotate(-parent.angle).add(parent.pos);this.angle=parent.getMirrorSign()*this.localAngle+parent.angle;return}this.velocity.x=clamp(this.velocity.x,-objectMaxSpeed,objectMaxSpeed);this.velocity.y=clamp(this.velocity.y,-objectMaxSpeed,objectMaxSpeed);const oldPos=this.pos.copy();this.velocity.y+=gravity*this.gravityScale;this.pos.x+=this.velocity.x*=this.damping;this.pos.y+=this.velocity.y*=this.damping;this.angle+=this.angleVelocity*=this.angleDamping;ASSERT(this.angleDamping>=0&&this.angleDamping<=1);ASSERT(this.damping>=0&&this.damping<=1);if(!enablePhysicsSolver||!this.mass)return;const wasMovingDown=this.velocity.y<0;if(this.groundObject){const groundSpeed=this.groundObject.velocity?this.groundObject.velocity.x:0;this.velocity.x=groundSpeed+(this.velocity.x-groundSpeed)*this.friction;this.groundObject=0}if(this.collideSolidObjects){const epsilon=.001;for(const o of engineObjectsCollide){if(!this.isSolid&!o.isSolid||o.destroyed||o.parent||o==this)continue;if(!isOverlapping(this.pos,this.size,o.pos,o.size))continue;if(!this.collideWithObject(o)|!o.collideWithObject(this))continue;if(isOverlapping(oldPos,this.size,o.pos,o.size)){const deltaPos=oldPos.subtract(o.pos);const length=deltaPos.length();const pushAwayAccel=.001;const velocity=length<.01?randVector(pushAwayAccel):deltaPos.scale(pushAwayAccel/length);this.velocity=this.velocity.add(velocity);if(o.mass)o.velocity=o.velocity.subtract(velocity);debugOverlay&&debugPhysics&&debugAABB(this.pos,this.size,o.pos,o.size,"#f00");continue}const sizeBoth=this.size.add(o.size);const smallStepUp=(oldPos.y-o.pos.y)*2>sizeBoth.y+gravity;const isBlockedX=abs(oldPos.y-o.pos.y)*2<sizeBoth.y;const isBlockedY=abs(oldPos.x-o.pos.x)*2<sizeBoth.x;const elasticity=max(this.elasticity,o.elasticity);if(smallStepUp|isBlockedY|!isBlockedX){this.pos.y=o.pos.y+(sizeBoth.y/2+epsilon)*sign(oldPos.y-o.pos.y);if(o.groundObject&&wasMovingDown||!o.mass){if(wasMovingDown)this.groundObject=o;this.velocity.y*=-elasticity}else if(o.mass){const inelastic=(this.mass*this.velocity.y+o.mass*o.velocity.y)/(this.mass+o.mass);const elastic0=this.velocity.y*(this.mass-o.mass)/(this.mass+o.mass)+o.velocity.y*2*o.mass/(this.mass+o.mass);const elastic1=o.velocity.y*(o.mass-this.mass)/(this.mass+o.mass)+this.velocity.y*2*this.mass/(this.mass+o.mass);this.velocity.y=lerp(elasticity,inelastic,elastic0);o.velocity.y=lerp(elasticity,inelastic,elastic1)}}if(!smallStepUp&isBlockedX){this.pos.x=o.pos.x+(sizeBoth.x/2+epsilon)*sign(oldPos.x-o.pos.x);if(o.mass){const inelastic=(this.mass*this.velocity.x+o.mass*o.velocity.x)/(this.mass+o.mass);const elastic0=this.velocity.x*(this.mass-o.mass)/(this.mass+o.mass)+o.velocity.x*2*o.mass/(this.mass+o.mass);const elastic1=o.velocity.x*(o.mass-this.mass)/(this.mass+o.mass)+this.velocity.x*2*this.mass/(this.mass+o.mass);this.velocity.x=lerp(elasticity,inelastic,elastic0);o.velocity.x=lerp(elasticity,inelastic,elastic1)}else this.velocity.x*=-elasticity}debugOverlay&&debugPhysics&&debugAABB(this.pos,this.size,o.pos,o.size,"#f0f")}}if(this.collideTiles){if(tileCollisionTest(this.pos,this.size,this)){if(!tileCollisionTest(oldPos,this.size,this)){const isBlockedY=tileCollisionTest(new Vector2(oldPos.x,this.pos.y),this.size,this);const isBlockedX=tileCollisionTest(new Vector2(this.pos.x,oldPos.y),this.size,this);if(isBlockedY|!isBlockedX){this.groundObject=wasMovingDown;this.velocity.y*=-this.elasticity;const o=(oldPos.y-this.size.y/2|0)-(oldPos.y-this.size.y/2);if(o<0&&o>this.damping*this.velocity.y+gravity*this.gravityScale)this.velocity.y=this.damping?(o-gravity*this.gravityScale)/this.damping:0;this.pos.y=oldPos.y}if(isBlockedX){this.pos.x=oldPos.x;this.velocity.x*=-this.elasticity}}}}}render(){drawTile(this.pos,this.drawSize||this.size,this.tileIndex,this.tileSize,this.color,this.angle,this.mirror,this.additiveColor)}destroy(){if(this.destroyed)return;this.destroyed=1;this.parent&&this.parent.removeChild(this);for(const child of this.children)child.destroy(child.parent=0)}collideWithTile(tileData,pos){return tileData>0}collideWithTileRaycast(tileData,pos){return tileData>0}collideWithObject(o){return 1}getAliveTime(){return time-this.spawnTime}applyAcceleration(a){if(this.mass)this.velocity=this.velocity.add(a)}applyForce(force){this.applyAcceleration(force.scale(1/this.mass))}getMirrorSign(){return this.mirror?-1:1}addChild(child,localPos=vec2(),localAngle=0){ASSERT(!child.parent&&!this.children.includes(child));this.children.push(child);child.parent=this;child.localPos=localPos.copy();child.localAngle=localAngle}removeChild(child){ASSERT(child.parent==this&&this.children.includes(child));this.children.splice(this.children.indexOf(child),1);child.parent=0}setCollision(collideSolidObjects=1,isSolid=1,collideTiles=1){ASSERT(collideSolidObjects||!isSolid);this.collideSolidObjects=collideSolidObjects;this.isSolid=isSolid;this.collideTiles=collideTiles}toString(){if(debug){let text="type = "+this.constructor.name;if(this.pos.x||this.pos.y)text+="\npos = "+this.pos;if(this.velocity.x||this.velocity.y)text+="\nvelocity = "+this.velocity;if(this.size.x||this.size.y)text+="\nsize = "+this.size;if(this.angle)text+="\nangle = "+this.angle.toFixed(3);if(this.color)text+="\ncolor = "+this.color;return text}}}"use strict";let mainCanvas;let mainContext;let overlayCanvas;let overlayContext;let mainCanvasSize=vec2();const tileImage=new Image;let tileImageSize,tileImageFixBleed,drawCount;const screenToWorld=screenPos=>{ASSERT(mainCanvasSize.x&&mainCanvasSize.y,"mainCanvasSize is invalid");return screenPos.add(vec2(.5)).subtract(mainCanvasSize.scale(.5)).multiply(vec2(1/cameraScale,-1/cameraScale)).add(cameraPos)};const worldToScreen=worldPos=>{ASSERT(mainCanvasSize.x&&mainCanvasSize.y,"mainCanvasSize is invalid");return worldPos.subtract(cameraPos).multiply(vec2(cameraScale,-cameraScale)).add(mainCanvasSize.scale(.5)).subtract(vec2(.5))};function drawTile(pos,size=vec2(1),tileIndex=-1,tileSize=tileSizeDefault,color=new Color,angle=0,mirror,additiveColor=new Color(0,0,0,0),useWebGL=glEnable){showWatermark&&++drawCount;if(glEnable&&useWebGL){if(tileIndex<0||!tileImage.width){glDraw(pos.x,pos.y,size.x,size.y,angle,0,0,0,0,0,color.rgbaInt())}else{const cols=tileImageSize.x/tileSize.x|0;const uvSizeX=tileSize.x/tileImageSize.x;const uvSizeY=tileSize.y/tileImageSize.y;const uvX=tileIndex%cols*uvSizeX,uvY=(tileIndex/cols|0)*uvSizeY;glDraw(pos.x,pos.y,mirror?-size.x:size.x,size.y,angle,uvX+tileImageFixBleed.x,uvY+tileImageFixBleed.y,uvX-tileImageFixBleed.x+uvSizeX,uvY-tileImageFixBleed.y+uvSizeY,color.rgbaInt(),additiveColor.rgbaInt())}}else{drawCanvas2D(pos,size,angle,mirror,context=>{if(tileIndex<0){context.fillStyle=color;context.fillRect(-.5,-.5,1,1)}else{const cols=tileImageSize.x/tileSize.x|0;const sX=tileIndex%cols*tileSize.x+tileFixBleedScale;const sY=(tileIndex/cols|0)*tileSize.y+tileFixBleedScale;const sWidth=tileSize.x-2*tileFixBleedScale;const sHeight=tileSize.y-2*tileFixBleedScale;context.globalAlpha=color.a;context.drawImage(tileImage,sX,sY,sWidth,sHeight,-.5,-.5,1,1)}})}}function drawRect(pos,size,color,angle,useWebGL){drawTile(pos,size,-1,tileSizeDefault,color,angle,0,0,useWebGL)}function drawTileScreenSpace(pos,size=vec2(1),tileIndex,tileSize,color,angle,mirror,additiveColor,useWebGL){drawTile(screenToWorld(pos),size.scale(1/cameraScale),tileIndex,tileSize,color,angle,mirror,additiveColor,useWebGL)}function drawRectScreenSpace(pos,size,color,angle,useWebGL){drawTileScreenSpace(pos,size,-1,tileSizeDefault,color,angle,0,0,useWebGL)}function drawLine(posA,posB,thickness=.1,color,useWebGL){const halfDelta=vec2((posB.x-posA.x)/2,(posB.y-posA.y)/2);const size=vec2(thickness,halfDelta.length()*2);drawRect(posA.add(halfDelta),size,color,halfDelta.angle(),useWebGL)}function drawCanvas2D(pos,size,angle,mirror,drawFunction,context=mainContext){pos=worldToScreen(pos);size=size.scale(cameraScale);context.save();context.translate(pos.x+.5|0,pos.y+.5|0);context.rotate(angle);context.scale(mirror?-size.x:size.x,size.y);drawFunction(context);context.restore()}function setBlendMode(additive,useWebGL=glEnable){if(glEnable&&useWebGL)glSetBlendMode(additive);else mainContext.globalCompositeOperation=additive?"lighter":"source-over"}function drawText(text,pos,size=1,color,lineWidth=0,lineColor,textAlign,font,context){drawTextScreen(text,worldToScreen(pos),size*cameraScale,color,lineWidth*cameraScale,lineColor,textAlign,font,context)}function drawTextScreen(text,pos,size=1,color=new Color,lineWidth=0,lineColor=new Color(0,0,0),textAlign="center",font=fontDefault,context=overlayContext){context.fillStyle=color;context.lineWidth=lineWidth;context.strokeStyle=lineColor;context.textAlign=textAlign;context.font=size+"px "+font;context.textBaseline="middle";context.lineJoin="round";pos=pos.copy();(text+"").split("\n").forEach(line=>{lineWidth&&context.strokeText(line,pos.x,pos.y);context.fillText(line,pos.x,pos.y);pos.y+=size})}let engineFontImage;class FontImage{constructor(image,tileSize=vec2(8),paddingSize=vec2(0,1),startTileIndex=0,context=overlayContext){if(!engineFontImage)(engineFontImage=new Image).src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAYAQAAAAA9+x6JAAAAAnRSTlMAAHaTzTgAAAGiSURBVHjaZZABhxxBEIUf6ECLBdFY+Q0PMNgf0yCgsSAGZcT9sgIPtBWwIA5wgAPEoHUyJeeSlW+gjK+fegWwtROWpVQEyWh2npdpBmTUFVhb29RINgLIukoXr5LIAvYQ5ve+1FqWEMqNKTX3FAJHyQDRZvmKWubAACcv5z5Gtg2oyCWE+Yk/8JZQX1jTTCpKAFGIgza+dJCNBF2UskRlsgwitHbSV0QLgt9sTPtsRlvJjEr8C/FARWA2bJ/TtJ7lko34dNDn6usJUMzuErP89UUBJbWeozrwLLncXczd508deAjLWipLO4Q5XGPcJvPu92cNDaN0P5G1FL0nSOzddZOrJ6rNhbXGmeDvO3TF7DeJWl4bvaYQTNHCTeuqKZmbjHaSOFes+IX/+IhHrnAkXOAsfn24EM68XieIECoccD4KZLk/odiwzeo2rovYdhvb2HYFgyznJyDpYJdYOmfXgVdJTaUi4xA2uWYNYec9BLeqdl9EsoTw582mSFDX2DxVLbNt9U3YYoeatBad1c2Tj8t2akrjaIGJNywKB/7h75/gN3vCMSaadIUTAAAAAElFTkSuQmCC";this.image=image||engineFontImage;this.tileSize=tileSize;this.paddingSize=paddingSize;this.startTileIndex=startTileIndex;this.context=context}drawTextScreen(text,pos,scale=4,center){const context=this.context;context.save();context.imageSmoothingEnabled=!cavasPixelated;const size=this.tileSize;const drawSize=size.add(this.paddingSize).scale(scale);const cols=this.image.width/this.tileSize.x|0;(text+"").split("\n").forEach((line,i)=>{const centerOffset=center?line.length*size.x*scale/2|0:0;for(let j=line.length;j--;){let charCode=line[j].charCodeAt();if(charCode<32||charCode>127)charCode=127;const tile=this.startTileIndex+charCode-32;const x=tile%cols;const y=tile/cols|0;const drawPos=pos.add(vec2(j,i).multiply(drawSize));context.drawImage(this.image,x*size.x,y*size.y,size.x,size.y,drawPos.x-centerOffset,drawPos.y,size.x*scale,size.y*scale)}});context.restore()}drawText(text,pos,scale=1,center){this.drawTextScreen(text,worldToScreen(pos).floor(),scale*cameraScale|0,center)}}const isFullscreen=()=>document.fullscreenElement;function toggleFullscreen(){if(isFullscreen()){if(document.exitFullscreen)document.exitFullscreen()}else if(document.body.requestFullscreen)document.body.requestFullscreen()}"use strict";const keyIsDown=(key,device=0)=>inputData[device]&&inputData[device][key]&1;const keyWasPressed=(key,device=0)=>inputData[device]&&inputData[device][key]&2?1:0;const keyWasReleased=(key,device=0)=>inputData[device]&&inputData[device][key]&4?1:0;const clearInput=()=>inputData=[[]];const mouseIsDown=keyIsDown;const mouseWasPressed=keyWasPressed;const mouseWasReleased=keyWasReleased;let mousePos=vec2();let mousePosScreen=vec2();let mouseWheel=0;let isUsingGamepad=0;let preventDefaultInput=0;const gamepadIsDown=(button,gamepad=0)=>keyIsDown(button,gamepad+1);const gamepadWasPressed=(button,gamepad=0)=>keyWasPressed(button,gamepad+1);const gamepadWasReleased=(button,gamepad=0)=>keyWasReleased(button,gamepad+1);const gamepadStick=(stick,gamepad=0)=>stickData[gamepad]?stickData[gamepad][stick]||vec2():vec2();let inputData=[[]];function inputUpdate(){isTouchDevice||document.hasFocus()||clearInput();mousePos=screenToWorld(mousePosScreen);gamepadsUpdate()}function inputUpdatePost(){for(const deviceInputData of inputData)for(const i in deviceInputData)deviceInputData[i]&=1;mouseWheel=0}onkeydown=e=>{if(debug&&e.target!=document.body)return;e.repeat||(inputData[isUsingGamepad=0][remapKey(e.which)]=3);preventDefaultInput&&e.preventDefault()};onkeyup=e=>{if(debug&&e.target!=document.body)return;inputData[0][remapKey(e.which)]=4};const remapKey=c=>inputWASDEmulateDirection?c==87?38:c==83?40:c==65?37:c==68?39:c:c;onmousedown=e=>{inputData[isUsingGamepad=0][e.button]=3;onmousemove(e);e.button&&e.preventDefault()};onmouseup=e=>inputData[0][e.button]=inputData[0][e.button]&2|4;onmousemove=e=>mousePosScreen=mouseToScreen(e);onwheel=e=>e.ctrlKey||(mouseWheel=sign(e.deltaY));oncontextmenu=e=>!1;const mouseToScreen=mousePos=>{if(!mainCanvas)return vec2();const rect=mainCanvas.getBoundingClientRect();return vec2(mainCanvas.width,mainCanvas.height).multiply(vec2(percent(mousePos.x,rect.left,rect.right),percent(mousePos.y,rect.top,rect.bottom)))};const stickData=[];function gamepadsUpdate(){if(touchGamepadEnable&&touchGamepadTimer.isSet()){const sticks=stickData[0]||(stickData[0]=[]);sticks[0]=vec2(touchGamepadStick.x,-touchGamepadStick.y);const data=inputData[1]||(inputData[1]=[]);for(let i=10;i--;){const j=i==3?2:i==2?3:i;data[j]=touchGamepadButtons[i]?1+2*!gamepadIsDown(j,0):4*gamepadIsDown(j,0)}}if(!gamepadsEnable||!navigator||!navigator.getGamepads||!document.hasFocus()&&!debug)return;const gamepads=navigator.getGamepads();for(let i=gamepads.length;i--;){const gamepad=gamepads[i];const data=inputData[i+1]||(inputData[i+1]=[]);const sticks=stickData[i]||(stickData[i]=[]);if(gamepad){const deadZone=.3,deadZoneMax=.8;const applyDeadZone=v=>v>deadZone?percent(v,deadZone,deadZoneMax):v<-deadZone?-percent(-v,deadZone,deadZoneMax):0;for(let j=0;j<gamepad.axes.length-1;j+=2)sticks[j>>1]=vec2(applyDeadZone(gamepad.axes[j]),applyDeadZone(-gamepad.axes[j+1])).clampLength();for(let j=gamepad.buttons.length;j--;){const button=gamepad.buttons[j];data[j]=button.pressed?1+2*!gamepadIsDown(j,i):4*gamepadIsDown(j,i);isUsingGamepad|=!i&&button.pressed;touchGamepadEnable&&touchGamepadTimer.unset()}if(gamepadDirectionEmulateStick){const dpad=vec2(gamepadIsDown(15,i)-gamepadIsDown(14,i),gamepadIsDown(12,i)-gamepadIsDown(13,i));if(dpad.lengthSquared())sticks[0]=dpad.clampLength()}}}}const vibrate=pattern=>vibrateEnable&&navigator&&navigator.vibrate&&navigator.vibrate(pattern);const vibrateStop=()=>vibrate(0);const isTouchDevice=window.ontouchstart!==undefined;if(isTouchDevice){let wasTouching,mouseDown=onmousedown,mouseUp=onmouseup;onmousedown=onmouseup=()=>0;ontouchstart=e=>{zzfx(0);ontouchstart=ontouchmove=ontouchend=e=>{e.button=0;const touching=e.touches.length;if(touching){e.x=e.touches[0].clientX;e.y=e.touches[0].clientY;wasTouching?onmousemove(e):mouseDown(e)}else if(wasTouching)mouseUp(e);wasTouching=touching;return true};touchGamepadEnable&&touchGamepadCreate();return ontouchstart(e)}}let touchGamepadTimer=new Timer,touchGamepadButtons,touchGamepadStick;function touchGamepadCreate(){touchGamepadButtons=[];touchGamepadStick=vec2();let touchHandler=ontouchstart;ontouchstart=ontouchmove=ontouchend=e=>{touchGamepadStick=vec2();touchGamepadButtons=[];const touching=e.touches.length;if(touching){touchGamepadTimer.set();if(paused){touchGamepadButtons[9]=1;return}}const stickCenter=vec2(touchGamepadSize,mainCanvasSize.y-touchGamepadSize);const buttonCenter=mainCanvasSize.subtract(vec2(touchGamepadSize,touchGamepadSize));const startCenter=mainCanvasSize.scale(.5);for(const touch of e.touches){const touchPos=mouseToScreen(vec2(touch.clientX,touch.clientY));if(touchPos.distance(stickCenter)<touchGamepadSize){if(touchGamepadAnalog)touchGamepadStick=touchPos.subtract(stickCenter).scale(2/touchGamepadSize).clampLength();else{const angle=touchPos.subtract(stickCenter).angle();touchGamepadStick.setAngle((angle*4/PI+8.5|0)*PI/4)}}else if(touchPos.distance(buttonCenter)<touchGamepadSize){const button=touchPos.subtract(buttonCenter).direction();touchGamepadButtons[button]=1}else if(touchPos.distance(startCenter)<touchGamepadSize){touchGamepadButtons[9]=1}}touchHandler(e);isUsingGamepad=1;return true}}function touchGamepadRender(){if(!touchGamepadEnable||!touchGamepadTimer.isSet())return;const alpha=percent(touchGamepadTimer,4,3);if(!alpha||paused)return;overlayContext.save();overlayContext.globalAlpha=alpha*touchGamepadAlpha;overlayContext.strokeStyle="#fff";overlayContext.lineWidth=3;overlayContext.fillStyle=touchGamepadStick.lengthSquared()>0?"#fff":"#000";overlayContext.beginPath();const leftCenter=vec2(touchGamepadSize,mainCanvasSize.y-touchGamepadSize);if(touchGamepadAnalog){overlayContext.arc(leftCenter.x,leftCenter.y,touchGamepadSize/2,0,9);overlayContext.fill();overlayContext.stroke()}else{for(let i=10;i--;){const angle=i*PI/4;overlayContext.arc(leftCenter.x,leftCenter.y,touchGamepadSize*.6,angle+PI/8,angle+PI/8);i%2&&overlayContext.arc(leftCenter.x,leftCenter.y,touchGamepadSize*.33,angle,angle);i==1&&overlayContext.fill()}overlayContext.stroke()}const rightCenter=vec2(mainCanvasSize.x-touchGamepadSize,mainCanvasSize.y-touchGamepadSize);for(let i=4;i--;){const pos=rightCenter.add((new Vector2).setAngle(i*PI/2,touchGamepadSize/2));overlayContext.fillStyle=touchGamepadButtons[i]?"#fff":"#000";overlayContext.beginPath();overlayContext.arc(pos.x,pos.y,touchGamepadSize/4,0,9);overlayContext.fill();overlayContext.stroke()}overlayContext.restore()}"use strict";class Sound{constructor(zzfxSound,range=soundDefaultRange,taper=soundDefaultTaper){if(!soundEnable)return;this.range=range;this.taper=taper;this.randomness=zzfxSound[1]||0;zzfxSound[1]=0;this.cachedSamples=zzfxG(...zzfxSound)}play(pos,volume=1,pitch=1,randomnessScale=1){if(!soundEnable)return;let pan;if(pos){const range=this.range;if(range){const lengthSquared=cameraPos.distanceSquared(pos);if(lengthSquared>range*range)return;volume*=percent(lengthSquared**.5,range,range*this.taper)}pan=worldToScreen(pos).x*2/mainCanvas.width-1}const playbackRate=pitch+pitch*this.randomness*randomnessScale*rand(-1,1);return playSamples([this.cachedSamples],volume,playbackRate,pan)}playNote(semitoneOffset,pos,volume){if(!soundEnable)return;return this.play(pos,volume,2**(semitoneOffset/12),0)}}class Music{constructor(zzfxMusic){if(!soundEnable)return;this.cachedSamples=zzfxM(...zzfxMusic)}play(volume,loop=1){if(!soundEnable)return;return this.source=playSamples(this.cachedSamples,volume,1,0,loop)}stop(){if(this.source)this.source.stop();this.source=0}isPlaying(){return this.source}}function playAudioFile(url,volume=1,loop=1){if(!soundEnable)return;const audio=new Audio(url);audio.volume=soundVolume*volume;audio.loop=loop;audio.play();return audio}function speak(text,language="",volume=1,rate=1,pitch=1){if(!soundEnable||!speechSynthesis)return;const utterance=new SpeechSynthesisUtterance(text);utterance.lang=language;utterance.volume=2*volume*soundVolume;utterance.rate=rate;utterance.pitch=pitch;speechSynthesis.speak(utterance);return utterance}const speakStop=()=>speechSynthesis&&speechSynthesis.cancel();const getNoteFrequency=(semitoneOffset,rootFrequency=220)=>rootFrequency*2**(semitoneOffset/12);let audioContext;function playSamples(sampleChannels,volume=1,rate=1,pan=0,loop=0){if(!soundEnable)return;if(!audioContext)audioContext=new AudioContext;audioContext.resume();if(audioContext.state!="running")return;const buffer=audioContext.createBuffer(sampleChannels.length,sampleChannels[0].length,zzfxR),source=audioContext.createBufferSource();sampleChannels.forEach((c,i)=>buffer.getChannelData(i).set(c));source.buffer=buffer;source.playbackRate.value=rate;source.loop=loop;const gainNode=audioContext.createGain();gainNode.gain.value=soundVolume*volume;gainNode.connect(audioContext.destination);source.connect(new StereoPannerNode(audioContext,{pan:clamp(pan,-1,1)})).connect(gainNode);source.start();return source}const zzfx=(...zzfxSound)=>playSamples([zzfxG(...zzfxSound)]);const zzfxR=44100;function zzfxG(volume=1,randomness=.05,frequency=220,attack=0,sustain=0,release=.1,shape=0,shapeCurve=1,slide=0,deltaSlide=0,pitchJump=0,pitchJumpTime=0,repeatTime=0,noise=0,modulation=0,bitCrush=0,delay=0,sustainVolume=1,decay=0,tremolo=0){let PI2=PI*2,startSlide=slide*=500*PI2/zzfxR/zzfxR,b=[],startFrequency=frequency*=(1+randomness*rand(-1,1))*PI2/zzfxR,t=0,tm=0,i=0,j=1,r=0,c=0,s=0,f,length;attack=attack*zzfxR+9;decay*=zzfxR;sustain*=zzfxR;release*=zzfxR;delay*=zzfxR;deltaSlide*=500*PI2/zzfxR**3;modulation*=PI2/zzfxR;pitchJump*=PI2/zzfxR;pitchJumpTime*=zzfxR;repeatTime=repeatTime*zzfxR|0;for(length=attack+decay+sustain+release+delay|0;i<length;b[i++]=s){if(!(++c%(bitCrush*100|0))){s=shape?shape>1?shape>2?shape>3?Math.sin((t%PI2)**3):max(min(Math.tan(t),1),-1):1-(2*t/PI2%2+2)%2:1-4*abs(Math.round(t/PI2)-t/PI2):Math.sin(t);s=(repeatTime?1-tremolo+tremolo*Math.sin(PI2*i/repeatTime):1)*sign(s)*abs(s)**shapeCurve*volume*soundVolume*(i<attack?i/attack:i<attack+decay?1-(i-attack)/decay*(1-sustainVolume):i<attack+decay+sustain?sustainVolume:i<length-delay?(length-i-delay)/release*sustainVolume:0);s=delay?s/2+(delay>i?0:(i<length-delay?1:(length-i)/delay)*b[i-delay|0]/2):s}f=(frequency+=slide+=deltaSlide)*Math.cos(modulation*tm++);t+=f-f*noise*(1-(Math.sin(i)+1)*1e9%2);if(j&&++j>pitchJumpTime){frequency+=pitchJump;startFrequency+=pitchJump;j=0}if(repeatTime&&!(++r%repeatTime)){frequency=startFrequency;slide=startSlide;j||=1}}return b}function zzfxM(instruments,patterns,sequence,BPM=125){let i,j,k;let instrumentParameters;let note;let sample;let patternChannel;let notFirstBeat;let stop;let instrument;let attenuation;let outSampleOffset;let isSequenceEnd;let sampleOffset=0;let nextSampleOffset;let sampleBuffer=[];let leftChannelBuffer=[];let rightChannelBuffer=[];let channelIndex=0;let panning=0;let hasMore=1;let sampleCache={};let beatLength=zzfxR/BPM*60>>2;for(;hasMore;channelIndex++){sampleBuffer=[hasMore=notFirstBeat=outSampleOffset=0];sequence.forEach((patternIndex,sequenceIndex)=>{patternChannel=patterns[patternIndex][channelIndex]||[0,0,0];hasMore|=!!patterns[patternIndex][channelIndex];nextSampleOffset=outSampleOffset+(patterns[patternIndex][0].length-2-!notFirstBeat)*beatLength;isSequenceEnd=sequenceIndex==sequence.length-1;for(i=2,k=outSampleOffset;i<patternChannel.length+isSequenceEnd;notFirstBeat=++i){note=patternChannel[i];stop=i==patternChannel.length+isSequenceEnd-1&&isSequenceEnd||instrument!=(patternChannel[0]||0)|note|0;for(j=0;j<beatLength&&notFirstBeat;j++>beatLength-99&&stop?attenuation+=(attenuation<1)/99:0){sample=(1-attenuation)*sampleBuffer[sampleOffset++]/2||0;leftChannelBuffer[k]=(leftChannelBuffer[k]||0)-sample*panning+sample;rightChannelBuffer[k]=(rightChannelBuffer[k++]||0)+sample*panning+sample}if(note){attenuation=note%1;panning=patternChannel[1]||0;if(note|=0){sampleBuffer=sampleCache[[instrument=patternChannel[sampleOffset=0]||0,note]]=sampleCache[[instrument,note]]||(instrumentParameters=[...instruments[instrument]],instrumentParameters[2]*=2**((note-12)/12),note>0?zzfxG(...instrumentParameters):[])}}}outSampleOffset=nextSampleOffset})}return[leftChannelBuffer,rightChannelBuffer]}"use strict";let tileCollision=[];let tileCollisionSize=vec2();function initTileCollision(size){tileCollisionSize=size;tileCollision=[];for(let i=tileCollision.length=tileCollisionSize.area();i--;)tileCollision[i]=0}const setTileCollisionData=(pos,data=0)=>pos.arrayCheck(tileCollisionSize)&&(tileCollision[(pos.y|0)*tileCollisionSize.x+pos.x|0]=data);const getTileCollisionData=pos=>pos.arrayCheck(tileCollisionSize)?tileCollision[(pos.y|0)*tileCollisionSize.x+pos.x|0]:0;function tileCollisionTest(pos,size=vec2(),object){const minX=max(pos.x-size.x/2|0,0);const minY=max(pos.y-size.y/2|0,0);const maxX=min(pos.x+size.x/2,tileCollisionSize.x);const maxY=min(pos.y+size.y/2,tileCollisionSize.y);for(let y=minY;y<maxY;++y)for(let x=minX;x<maxX;++x){const tileData=tileCollision[y*tileCollisionSize.x+x];if(tileData&&(!object||object.collideWithTile(tileData,new Vector2(x,y))))return 1}}function tileCollisionRaycast(posStart,posEnd,object){const posDelta=(posEnd=posEnd.floor()).subtract(posStart=posStart.floor());const dx=abs(posDelta.x),dy=-abs(posDelta.y);const sx=sign(posDelta.x),sy=sign(posDelta.y);for(let x=posStart.x,y=posStart.y,e=dx+dy;;){const tileData=getTileCollisionData(vec2(x,y));if(tileData&&(object?object.collideWithTileRaycast(tileData,new Vector2(x,y)):tileData>0)){debugRaycast&&debugLine(posStart,posEnd,"#f00",.02,1);debugRaycast&&debugPoint(new Vector2(x+.5,y+.5),"#ff0",1);return new Vector2(x+.5,y+.5)}if(x==posEnd.x&y==posEnd.y)break;const e2=2*e;if(e2>=dy)e+=dy,x+=sx;if(e2<=dx)e+=dx,y+=sy}debugRaycast&&debugLine(posStart,posEnd,"#00f",.02,1)}class TileLayerData{constructor(tile,direction=0,mirror=0,color=new Color){this.tile=tile;this.direction=direction;this.mirror=mirror;this.color=color}clear(){this.tile=this.direction=this.mirror=0;color=new Color}}class TileLayer extends EngineObject{constructor(pos,size=tileCollisionSize,tileSize=tileSizeDefault,scale=vec2(1),renderOrder=0){super(pos,size,-1,tileSize,0,undefined,renderOrder);this.canvas=document.createElement("canvas");this.context=this.canvas.getContext("2d");this.scale=scale;this.isOverlay;this.data=[];for(let j=this.size.area();j--;)this.data.push(new TileLayerData)}setData(layerPos,data,redraw){if(layerPos.arrayCheck(this.size)){this.data[(layerPos.y|0)*this.size.x+layerPos.x|0]=data;redraw&&this.drawTileData(layerPos)}}getData(layerPos){return layerPos.arrayCheck(this.size)&&this.data[(layerPos.y|0)*this.size.x+layerPos.x|0]}update(){}render(){ASSERT(mainContext!=this.context);glEnable&&!glOverlay&&!this.isOverlay&&glCopyToContext(mainContext);const pos=worldToScreen(this.pos.add(vec2(0,this.size.y*this.scale.y)));(this.isOverlay?overlayContext:mainContext).drawImage(this.canvas,pos.x,pos.y,cameraScale*this.size.x*this.scale.x,cameraScale*this.size.y*this.scale.y)}redraw(){this.redrawStart(1);this.drawAllTileData();this.redrawEnd()}redrawStart(clear=0){this.savedRenderSettings=[mainCanvas,mainContext,mainCanvasSize,cameraPos,cameraScale];mainCanvas=this.canvas;mainContext=this.context;cameraPos=this.size.scale(.5);cameraScale=this.tileSize.x;if(clear){mainCanvas.width=this.size.x*this.tileSize.x;mainCanvas.height=this.size.y*this.tileSize.y}enginePreRender()}redrawEnd(){ASSERT(mainContext==this.context);glEnable&&glCopyToContext(mainContext,1);[mainCanvas,mainContext,mainCanvasSize,cameraPos,cameraScale]=this.savedRenderSettings}drawTileData(layerPos){const pos=layerPos.floor().add(this.pos).add(vec2(.5));this.drawCanvas2D(pos,vec2(1),0,0,context=>context.clearRect(-.5,-.5,1,1));const d=this.getData(layerPos);if(d.tile!=undefined){ASSERT(mainContext==this.context);drawTile(pos,vec2(1),d.tile,this.tileSize,d.color,d.direction*PI/2,d.mirror)}}drawAllTileData(){for(let x=this.size.x;x--;)for(let y=this.size.y;y--;)this.drawTileData(vec2(x,y))}drawCanvas2D(pos,size,angle=0,mirror,drawFunction){const context=this.context;context.save();pos=pos.subtract(this.pos).multiply(this.tileSize);size=size.multiply(this.tileSize);context.translate(pos.x,this.canvas.height-pos.y);context.rotate(angle);context.scale(mirror?-size.x:size.x,size.y);drawFunction(context);context.restore()}drawTile(pos,size=vec2(1),tileIndex=-1,tileSize=tileSizeDefault,color=new Color,angle,mirror){this.drawCanvas2D(pos,size,angle,mirror,context=>{if(tileIndex<0){context.fillStyle=color;context.fillRect(-.5,-.5,1,1)}else{const cols=tileImage.width/tileSize.x;context.globalAlpha=color.a;context.drawImage(tileImage,tileIndex%cols*tileSize.x,(tileIndex/cols|0)*tileSize.y,tileSize.x,tileSize.y,-.5,-.5,1,1)}})}drawRect(pos,size,color,angle){this.drawTile(pos,size,-1,0,color,angle)}}"use strict";class ParticleEmitter extends EngineObject{constructor(pos,angle,emitSize=0,emitTime=0,emitRate=100,emitConeAngle=PI,tileIndex=-1,tileSize=tileSizeDefault,colorStartA=new Color,colorStartB=new Color,colorEndA=new Color(1,1,1,0),colorEndB=new Color(1,1,1,0),particleTime=.5,sizeStart=.1,sizeEnd=1,speed=.1,angleSpeed=.05,damping=1,angleDamping=1,gravityScale=0,particleConeAngle=PI,fadeRate=.1,randomness=.2,collideTiles,additive,randomColorLinear=1,renderOrder=additive?1e9:0,localSpace){super(pos,new Vector2,tileIndex,tileSize,angle,undefined,renderOrder);this.emitSize=emitSize;this.emitTime=emitTime;this.emitRate=emitRate;this.emitConeAngle=emitConeAngle;this.colorStartA=colorStartA;this.colorStartB=colorStartB;this.colorEndA=colorEndA;this.colorEndB=colorEndB;this.randomColorLinear=randomColorLinear;this.particleTime=particleTime;this.sizeStart=sizeStart;this.sizeEnd=sizeEnd;this.speed=speed;this.angleSpeed=angleSpeed;this.damping=damping;this.angleDamping=angleDamping;this.gravityScale=gravityScale;this.particleConeAngle=particleConeAngle;this.fadeRate=fadeRate;this.randomness=randomness;this.collideTiles=collideTiles;this.additive=additive;this.localSpace=localSpace;this.trailScale=0;this.emitTimeBuffer=0}update(){this.parent&&super.update();if(!this.emitTime|this.getAliveTime()<=this.emitTime){if(this.emitRate*particleEmitRateScale){const rate=1/this.emitRate/particleEmitRateScale;for(this.emitTimeBuffer+=timeDelta;this.emitTimeBuffer>0;this.emitTimeBuffer-=rate)this.emitParticle()}}else this.destroy();debugParticles&&debugRect(this.pos,vec2(this.emitSize),"#0f0",0,this.angle)}emitParticle(){let pos=this.emitSize.x!=undefined?new Vector2(rand(-.5,.5),rand(-.5,.5)).multiply(this.emitSize).rotate(this.angle):randInCircle(this.emitSize/2);let angle=rand(this.particleConeAngle,-this.particleConeAngle);if(!this.localSpace){pos=this.pos.add(pos);angle+=this.angle}const particle=new Particle(pos,this.tileIndex,this.tileSize,angle);const randomness=this.randomness;const randomizeScale=v=>v+v*rand(randomness,-randomness);const particleTime=randomizeScale(this.particleTime);const sizeStart=randomizeScale(this.sizeStart);const sizeEnd=randomizeScale(this.sizeEnd);const speed=randomizeScale(this.speed);const angleSpeed=randomizeScale(this.angleSpeed)*randSign();const coneAngle=rand(this.emitConeAngle,-this.emitConeAngle);const colorStart=randColor(this.colorStartA,this.colorStartB,this.randomColorLinear);const colorEnd=randColor(this.colorEndA,this.colorEndB,this.randomColorLinear);const velocityAngle=this.localSpace?coneAngle:this.angle+coneAngle;particle.colorStart=colorStart;particle.colorEndDelta=colorEnd.subtract(colorStart);particle.velocity=(new Vector2).setAngle(velocityAngle,speed);particle.angleVelocity=angleSpeed;particle.lifeTime=particleTime;particle.sizeStart=sizeStart;particle.sizeEndDelta=sizeEnd-sizeStart;particle.fadeRate=this.fadeRate;particle.damping=this.damping;particle.angleDamping=this.angleDamping;particle.elasticity=this.elasticity;particle.friction=this.friction;particle.gravityScale=this.gravityScale;particle.collideTiles=this.collideTiles;particle.additive=this.additive;particle.renderOrder=this.renderOrder;particle.trailScale=this.trailScale;particle.mirror=randInt(2);particle.localSpaceEmitter=this.localSpace&&this;particle.destroyCallback=this.particleDestroyCallback;this.particleCreateCallback&&this.particleCreateCallback(particle);return particle}render(){}}class Particle extends EngineObject{constructor(pos,tileIndex,tileSize,angle){super(pos,new Vector2,tileIndex,tileSize,angle)}render(){const p=min((time-this.spawnTime)/this.lifeTime,1);const radius=this.sizeStart+p*this.sizeEndDelta;const size=new Vector2(radius,radius);const fadeRate=this.fadeRate/2;const color=new Color(this.colorStart.r+p*this.colorEndDelta.r,this.colorStart.g+p*this.colorEndDelta.g,this.colorStart.b+p*this.colorEndDelta.b,(this.colorStart.a+p*this.colorEndDelta.a)*(p<fadeRate?p/fadeRate:p>1-fadeRate?(1-p)/fadeRate:1));this.additive&&setBlendMode(1);let pos=this.pos,angle=this.angle;if(this.localSpaceEmitter){pos=this.localSpaceEmitter.pos.add(pos.rotate(-this.localSpaceEmitter.angle));angle+=this.localSpaceEmitter.angle}if(this.trailScale){let velocity=this.velocity;if(this.localSpaceEmitter)velocity=velocity.rotate(-this.localSpaceEmitter.angle);const speed=velocity.length();const direction=velocity.scale(1/speed);const trailLength=speed*this.trailScale;size.y=max(size.x,trailLength);angle=direction.angle();drawTile(pos.add(direction.multiply(vec2(0,-trailLength/2))),size,this.tileIndex,this.tileSize,color,angle,this.mirror)}else drawTile(pos,size,this.tileIndex,this.tileSize,color,angle,this.mirror);this.additive&&setBlendMode();debugParticles&&debugRect(pos,size,"#f005",0,angle);if(p==1){this.color=color;this.size=size;this.destroyCallback&&this.destroyCallback(this);this.destroyed=1}}}"use strict";const medals=[];let medalsDisplayQueue=[],medalsSaveName,medalsDisplayTimeLast;function medalsInit(saveName){medalsSaveName=saveName;debugMedals||medals.forEach(medal=>medal.unlocked=localStorage[medal.storageKey()]|0)}class Medal{constructor(id,name,description="",icon="ðŸ†",src){ASSERT(id>=0&&!medals[id]);medals[this.id=id]=this;this.name=name;this.description=description;this.icon=icon;if(src)(this.image=new Image).src=src}unlock(){if(medalsPreventUnlock||this.unlocked)return;ASSERT(medalsSaveName);localStorage[this.storageKey()]=this.unlocked=1;medalsDisplayQueue.push(this);newgrounds&&newgrounds.unlockMedal(this.id)}render(hidePercent=0){const context=overlayContext;const width=min(medalDisplaySize.x,mainCanvas.width);const x=overlayCanvas.width-width;const y=-medalDisplaySize.y*hidePercent;context.save();context.beginPath();context.fillStyle=new Color(.9,.9,.9);context.strokeStyle=new Color(0,0,0);context.lineWidth=3;context.fill(context.rect(x,y,width,medalDisplaySize.y));context.stroke();context.clip();this.renderIcon(vec2(x+15+medalDisplayIconSize/2,y+medalDisplaySize.y/2));const pos=vec2(x+medalDisplayIconSize+30,y+28);drawTextScreen(this.name,pos,38,new Color(0,0,0),0,0,"left");pos.y+=32;drawTextScreen(this.description,pos,24,new Color(0,0,0),0,0,"left");context.restore()}renderIcon(pos,size=medalDisplayIconSize){if(this.image)overlayContext.drawImage(this.image,pos.x-size/2,pos.y-size/2,size,size);else drawTextScreen(this.icon,pos,size*.7,new Color(0,0,0))}storageKey(){return medalsSaveName+"_"+this.id}}function medalsRender(){if(!medalsDisplayQueue.length)return;const medal=medalsDisplayQueue[0];const time=timeReal-medalsDisplayTimeLast;if(!medalsDisplayTimeLast)medalsDisplayTimeLast=timeReal;else if(time>medalDisplayTime)medalsDisplayQueue.shift(medalsDisplayTimeLast=0);else{const slideOffTime=medalDisplayTime-medalDisplaySlideTime;const hidePercent=time<medalDisplaySlideTime?1-time/medalDisplaySlideTime:time>slideOffTime?(time-slideOffTime)/medalDisplaySlideTime:0;medal.render(hidePercent)}}let newgrounds;function newgroundsInit(app_id,cipher){newgrounds=new Newgrounds(app_id,cipher)}class Newgrounds{constructor(app_id,cipher){ASSERT(!newgrounds&&app_id);this.app_id=app_id;this.cipher=cipher;this.host=location?location.hostname:"";if(cipher)this.cryptoJS=this.CryptoJS();const url=new URL(location.href);this.session_id=url.searchParams.get("ngio_session_id");if(!this.session_id)return;const medalsResult=this.call("Medal.getList");this.medals=medalsResult?medalsResult.result.data["medals"]:[];debugMedals&&console.log(this.medals);for(const newgroundsMedal of this.medals){const medal=medals[newgroundsMedal["id"]];if(medal){medal.image=new Image;medal.image.src=newgroundsMedal["icon"];medal.name=newgroundsMedal["name"];medal.description=newgroundsMedal["description"];medal.unlocked=newgroundsMedal["unlocked"];medal.difficulty=newgroundsMedal["difficulty"];medal.value=newgroundsMedal["value"];if(medal.value)medal.description=medal.description+" ("+medal.value+")"}}const scoreboardResult=this.call("ScoreBoard.getBoards");this.scoreboards=scoreboardResult?scoreboardResult.result.data.scoreboards:[];debugMedals&&console.log(this.scoreboards);const keepAliveMS=5*60*1e3;setInterval(()=>this.call("Gateway.ping",0,1),keepAliveMS)}unlockMedal(id){return this.call("Medal.unlock",{id:id},1)}postScore(id,value){return this.call("ScoreBoard.postScore",{id:id,value:value},1)}getScores(id,user=0,social=0,skip=0,limit=10){return this.call("ScoreBoard.getScores",{id:id,user:user,social:social,skip:skip,limit:limit})}logView(){return this.call("App.logView",{host:this.host},1)}call(component,parameters=0,async=0){const call={component:component,parameters:parameters};if(this.cipher){const cryptoJS=this.cryptoJS;const aesKey=cryptoJS["enc"]["Base64"]["parse"](this.cipher);const iv=cryptoJS["lib"]["WordArray"]["random"](16);const encrypted=cryptoJS["AES"]["encrypt"](JSON.stringify(call),aesKey,{iv:iv});call["secure"]=cryptoJS["enc"]["Base64"]["stringify"](iv.concat(encrypted["ciphertext"]));call["parameters"]=0}const input={app_id:this.app_id,session_id:this.session_id,call:call};const formData=new FormData;formData.append("input",JSON.stringify(input));const xmlHttp=new XMLHttpRequest;const url="https://newgrounds.io/gateway_v3.php";xmlHttp.open("POST",url,!debugMedals&&async);xmlHttp.send(formData);debugMedals&&console.log(xmlHttp.responseText);return xmlHttp.responseText&&JSON.parse(xmlHttp.responseText)}CryptoJS(){return eval(Function("[M='GBMGXz^oVYPPKKbB`agTXU|LxPc_ZBcMrZvCr~wyGfWrwk@ATqlqeTp^N?p{we}jIpEnB_sEr`l?YDkDhWhprc|Er|XETG?pTl`e}dIc[_N~}fzRycIfpW{HTolvoPB_FMe_eH~BTMx]yyOhv?biWPCGc]kABencBhgERHGf{OL`Dj`c^sh@canhy[secghiyotcdOWgO{tJIE^JtdGQRNSCrwKYciZOa]Y@tcRATYKzv|sXpboHcbCBf`}SKeXPFM|RiJsSNaIb]QPc[D]Jy_O^XkOVTZep`ONmntLL`Qz~UupHBX_Ia~WX]yTRJIxG`ioZ{fefLJFhdyYoyLPvqgH?b`[TMnTwwfzDXhfM?rKs^aFr|nyBdPmVHTtAjXoYUloEziWDCw_suyYT~lSMksI~ZNCS[Bex~j]Vz?kx`gdYSEMCsHpjbyxQvw|XxX_^nQYue{sBzVWQKYndtYQMWRef{bOHSfQhiNdtR{o?cUAHQAABThwHPT}F{VvFmgN`E@FiFYS`UJmpQNM`X|tPKHlccT}z}k{sACHL?Rt@MkWplxO`ASgh?hBsuuP|xD~LSH~KBlRs]t|l|_tQAroDRqWS^SEr[sYdPB}TAROtW{mIkE|dWOuLgLmJrucGLpebrAFKWjikTUzS|j}M}szasKOmrjy[?hpwnEfX[jGpLt@^v_eNwSQHNwtOtDgWD{rk|UgASs@mziIXrsHN_|hZuxXlPJOsA^^?QY^yGoCBx{ekLuZzRqQZdsNSx@ezDAn{XNj@fRXIwrDX?{ZQHwTEfu@GhxDOykqts|n{jOeZ@c`dvTY?e^]ATvWpb?SVyg]GC?SlzteilZJAL]mlhLjYZazY__qcVFYvt@|bIQnSno@OXyt]OulzkWqH`rYFWrwGs`v|~XeTsIssLrbmHZCYHiJrX}eEzSssH}]l]IhPQhPoQ}rCXLyhFIT[clhzYOvyHqigxmjz`phKUU^TPf[GRAIhNqSOdayFP@FmKmuIzMOeoqdpxyCOwCthcLq?n`L`tLIBboNn~uXeFcPE{C~mC`h]jUUUQe^`UqvzCutYCgct|SBrAeiYQW?X~KzCz}guXbsUw?pLsg@hDArw?KeJD[BN?GD@wgFWCiHq@Ypp_QKFixEKWqRp]oJFuVIEvjDcTFu~Zz]a{IcXhWuIdMQjJ]lwmGQ|]g~c]Hl]pl`Pd^?loIcsoNir_kikBYyg?NarXZEGYspt_vLBIoj}LI[uBFvm}tbqvC|xyR~a{kob|HlctZslTGtPDhBKsNsoZPuH`U`Fqg{gKnGSHVLJ^O`zmNgMn~{rsQuoymw^JY?iUBvw_~mMr|GrPHTERS[MiNpY[Mm{ggHpzRaJaoFomtdaQ_?xuTRm}@KjU~RtPsAdxa|uHmy}n^i||FVL[eQAPrWfLm^ndczgF~Nk~aplQvTUpHvnTya]kOenZlLAQIm{lPl@CCTchvCF[fI{^zPkeYZTiamoEcKmBMfZhk_j_~Fjp|wPVZlkh_nHu]@tP|hS@^G^PdsQ~f[RqgTDqezxNFcaO}HZhb|MMiNSYSAnQWCDJukT~e|OTgc}sf[cnr?fyzTa|EwEtRG|I~|IO}O]S|rp]CQ}}DWhSjC_|z|oY|FYl@WkCOoPuWuqr{fJu?Brs^_EBI[@_OCKs}?]O`jnDiXBvaIWhhMAQDNb{U`bqVR}oqVAvR@AZHEBY@depD]OLh`kf^UsHhzKT}CS}HQKy}Q~AeMydXPQztWSSzDnghULQgMAmbWIZ|lWWeEXrE^EeNoZApooEmrXe{NAnoDf`m}UNlRdqQ@jOc~HLOMWs]IDqJHYoMziEedGBPOxOb?[X`KxkFRg@`mgFYnP{hSaxwZfBQqTm}_?RSEaQga]w[vxc]hMne}VfSlqUeMo_iqmd`ilnJXnhdj^EEFifvZyxYFRf^VaqBhLyrGlk~qowqzHOBlOwtx?i{m~`n^G?Yxzxux}b{LSlx]dS~thO^lYE}bzKmUEzwW^{rPGhbEov[Plv??xtyKJshbG`KuO?hjBdS@Ru}iGpvFXJRrvOlrKN?`I_n_tplk}kgwSXuKylXbRQ]]?a|{xiT[li?k]CJpwy^o@ebyGQrPfF`aszGKp]baIx~H?ElETtFh]dz[OjGl@C?]VDhr}OE@V]wLTc[WErXacM{We`F|utKKjgllAxvsVYBZ@HcuMgLboFHVZmi}eIXAIFhS@A@FGRbjeoJWZ_NKd^oEH`qgy`q[Tq{x?LRP|GfBFFJV|fgZs`MLbpPYUdIV^]mD@FG]pYAT^A^RNCcXVrPsgk{jTrAIQPs_`mD}rOqAZA[}RETFz]WkXFTz_m{N@{W@_fPKZLT`@aIqf|L^Mb|crNqZ{BVsijzpGPEKQQZGlApDn`ruH}cvF|iXcNqK}cxe_U~HRnKV}sCYb`D~oGvwG[Ca|UaybXea~DdD~LiIbGRxJ_VGheI{ika}KC[OZJLn^IBkPrQj_EuoFwZ}DpoBRcK]Q}?EmTv~i_Tul{bky?Iit~tgS|o}JL_VYcCQdjeJ_MfaA`FgCgc[Ii|CBHwq~nbJeYTK{e`CNstKfTKPzw{jdhp|qsZyP_FcugxCFNpKitlR~vUrx^NrSVsSTaEgnxZTmKc`R|lGJeX}ccKLsQZQhsFkeFd|ckHIVTlGMg`~uPwuHRJS_CPuN_ogXe{Ba}dO_UBhuNXby|h?JlgBIqMKx^_u{molgL[W_iavNQuOq?ap]PGB`clAicnl@k~pA?MWHEZ{HuTLsCpOxxrKlBh]FyMjLdFl|nMIvTHyGAlPogqfZ?PlvlFJvYnDQd}R@uAhtJmDfe|iJqdkYr}r@mEjjIetDl_I`TELfoR|qTBu@Tic[BaXjP?dCS~MUK[HPRI}OUOwAaf|_}HZzrwXvbnNgltjTwkBE~MztTQhtRSWoQHajMoVyBBA`kdgK~h`o[J`dm~pm]tk@i`[F~F]DBlJKklrkR]SNw@{aG~Vhl`KINsQkOy?WhcqUMTGDOM_]bUjVd|Yh_KUCCgIJ|LDIGZCPls{RzbVWVLEhHvWBzKq|^N?DyJB|__aCUjoEgsARki}j@DQXS`RNU|DJ^a~d{sh_Iu{ONcUtSrGWW@cvUjefHHi}eSSGrNtO?cTPBShLqzwMVjWQQCCFB^culBjZHEK_{dO~Q`YhJYFn]jq~XSnG@[lQr]eKrjXpG~L^h~tDgEma^AUFThlaR{xyuP@[^VFwXSeUbVetufa@dX]CLyAnDV@Bs[DnpeghJw^?UIana}r_CKGDySoRudklbgio}kIDpA@McDoPK?iYcG?_zOmnWfJp}a[JLR[stXMo?_^Ng[whQlrDbrawZeSZ~SJstIObdDSfAA{MV}?gNunLOnbMv_~KFQUAjIMj^GkoGxuYtYbGDImEYiwEMyTpMxN_LSnSMdl{bg@dtAnAMvhDTBR_FxoQgANniRqxd`pWv@rFJ|mWNWmh[GMJz_Nq`BIN@KsjMPASXORcdHjf~rJfgZYe_uulzqM_KdPlMsuvU^YJuLtofPhGonVOQxCMuXliNvJIaoC?hSxcxKVVxWlNs^ENDvCtSmO~WxI[itnjs^RDvI@KqG}YekaSbTaB]ki]XM@[ZnDAP~@|BzLRgOzmjmPkRE@_sobkT|SszXK[rZN?F]Z_u}Yue^[BZgLtR}FHzWyxWEX^wXC]MJmiVbQuBzkgRcKGUhOvUc_bga|Tx`KEM`JWEgTpFYVeXLCm|mctZR@uKTDeUONPozBeIkrY`cz]]~WPGMUf`MNUGHDbxZuO{gmsKYkAGRPqjc|_FtblEOwy}dnwCHo]PJhN~JoteaJ?dmYZeB^Xd?X^pOKDbOMF@Ugg^hETLdhwlA}PL@_ur|o{VZosP?ntJ_kG][g{Zq`Tu]dzQlSWiKfnxDnk}KOzp~tdFstMobmy[oPYjyOtUzMWdjcNSUAjRuqhLS@AwB^{BFnqjCmmlk?jpn}TksS{KcKkDboXiwK]qMVjm~V`LgWhjS^nLGwfhAYrjDSBL_{cRus~{?xar_xqPlArrYFd?pHKdMEZzzjJpfC?Hv}mAuIDkyBxFpxhstTx`IO{rp}XGuQ]VtbHerlRc_LFGWK[XluFcNGUtDYMZny[M^nVKVeMllQI[xtvwQnXFlWYqxZZFp_|]^oWX[{pOMpxXxvkbyJA[DrPzwD|LW|QcV{Nw~U^dgguSpG]ClmO@j_TENIGjPWwgdVbHganhM?ema|dBaqla|WBd`poj~klxaasKxGG^xbWquAl~_lKWxUkDFagMnE{zHug{b`A~IYcQYBF_E}wiA}K@yxWHrZ{[d~|ARsYsjeNWzkMs~IOqqp[yzDE|WFrivsidTcnbHFRoW@XpAV`lv_zj?B~tPCppRjgbbDTALeFaOf?VcjnKTQMLyp{NwdylHCqmo?oelhjWuXj~}{fpuX`fra?GNkDiChYgVSh{R[BgF~eQa^WVz}ATI_CpY?g_diae]|ijH`TyNIF}|D_xpmBq_JpKih{Ba|sWzhnAoyraiDvk`h{qbBfsylBGmRH}DRPdryEsSaKS~tIaeF[s]I~xxHVrcNe@Jjxa@jlhZueLQqHh_]twVMqG_EGuwyab{nxOF?`HCle}nBZzlTQjkLmoXbXhOtBglFoMz?eqre`HiE@vNwBulglmQjj]DB@pPkPUgA^sjOAUNdSu_`oAzar?n?eMnw{{hYmslYi[TnlJD'",..."]charCodeAtUinyxpf","for(;e<10359;c[e++]=p-=128,A=A?p-A&&A:p==34&&p)for(p=1;p<128;y=f.map((n,x)=>(U=r[n]*2+1,U=Math.log(U/(h-U)),t-=a[x]*U,U/500)),t=~-h/(1+Math.exp(t))|1,i=o%h<t,o=o%h+(i?t:h-t)*(o>>17)-!i*t,f.map((n,x)=>(U=r[n]+=(i*h/2-r[n]<<13)/((C[n]+=C[n]<5)+1/20)>>13,a[x]+=y[x]*(i-t/h))),p=p*2+i)for(f='010202103203210431053105410642065206541'.split(t=0).map((n,x)=>(U=0,[...n].map((n,x)=>(U=U*997+(c[e-n]|0)|0)),h*32-1&U*997+p+!!A*129)*12+x);o<h*32;o=o*64|M.charCodeAt(d++)&63);for(C=String.fromCharCode(...c);r=/[\0-#?@\\\\~]/.exec(C);)with(C.split(r))C=join(shift());return C")([],[],1<<17,[0,0,0,0,0,0,0,0,0,0,0,0],new Uint16Array(51e6).fill(1<<15),new Uint8Array(51e6),0,0,0,0))}}"use strict";let glCanvas;let glContext;let glTileTexture;let glActiveTexture,glShader,glArrayBuffer,glPositionData,glColorData,glBatchCount,glBatchAdditive,glAdditive;function glInit(){glCanvas=document.createElement("canvas");glContext=glCanvas.getContext("webgl",{antialias:false});glTileTexture=glCreateTexture(tileImage);glOverlay&&document.body.appendChild(glCanvas);glShader=glCreateProgram("precision highp float;"+"uniform mat4 m;"+"attribute vec2 p,t;"+"attribute vec4 c,a;"+"varying vec4 v,d,e;"+"void main(){"+"gl_Position=m*vec4(p,1,1);"+"v=vec4(t,p);d=c;e=a;"+"}","precision highp float;"+"varying vec4 v,d,e;"+"uniform sampler2D s;"+"void main(){"+"gl_FragColor=texture2D(s,v.xy)*d+e;"+"}");const vertexData=new ArrayBuffer(gl_VERTEX_BUFFER_SIZE);glArrayBuffer=glContext.createBuffer();glPositionData=new Float32Array(vertexData);glColorData=new Uint32Array(vertexData);glBatchCount=0}function glSetBlendMode(additive){glAdditive=additive}function glSetTexture(texture=glTileTexture){if(texture!=glActiveTexture)glFlush();glContext.bindTexture(gl_TEXTURE_2D,glActiveTexture=texture)}function glCompileShader(source,type){const shader=glContext.createShader(type);glContext.shaderSource(shader,source);glContext.compileShader(shader);if(debug&&!glContext.getShaderParameter(shader,gl_COMPILE_STATUS))throw glContext.getShaderInfoLog(shader);return shader}function glCreateProgram(vsSource,fsSource){const program=glContext.createProgram();glContext.attachShader(program,glCompileShader(vsSource,gl_VERTEX_SHADER));glContext.attachShader(program,glCompileShader(fsSource,gl_FRAGMENT_SHADER));glContext.linkProgram(program);if(debug&&!glContext.getProgramParameter(program,gl_LINK_STATUS))throw glContext.getProgramInfoLog(program);return program}function glCreateTexture(image){const texture=glContext.createTexture();glContext.bindTexture(gl_TEXTURE_2D,texture);image&&image.width&&glContext.texImage2D(gl_TEXTURE_2D,0,gl_RGBA,gl_RGBA,gl_UNSIGNED_BYTE,image);const filter=cavasPixelated?gl_NEAREST:gl_LINEAR;glContext.texParameteri(gl_TEXTURE_2D,gl_TEXTURE_MIN_FILTER,filter);glContext.texParameteri(gl_TEXTURE_2D,gl_TEXTURE_MAG_FILTER,filter);glContext.texParameteri(gl_TEXTURE_2D,gl_TEXTURE_WRAP_S,gl_CLAMP_TO_EDGE);glContext.texParameteri(gl_TEXTURE_2D,gl_TEXTURE_WRAP_T,gl_CLAMP_TO_EDGE);return texture}function glPreRender(){glContext.viewport(0,0,glCanvas.width=mainCanvas.width,glCanvas.height=mainCanvas.height);glContext.clear(gl_COLOR_BUFFER_BIT);glContext.useProgram(glShader);glContext.activeTexture(gl_TEXTURE0);glContext.bindTexture(gl_TEXTURE_2D,glActiveTexture=glTileTexture);glContext.bindBuffer(gl_ARRAY_BUFFER,glArrayBuffer);glContext.bufferData(gl_ARRAY_BUFFER,gl_VERTEX_BUFFER_SIZE,gl_DYNAMIC_DRAW);glSetBlendMode();let offset=0;const initVertexAttribArray=(name,type,typeSize,size,normalize=0)=>{const location=glContext.getAttribLocation(glShader,name);glContext.enableVertexAttribArray(location);glContext.vertexAttribPointer(location,size,type,normalize,gl_VERTEX_BYTE_STRIDE,offset);offset+=size*typeSize};initVertexAttribArray("p",gl_FLOAT,4,2);initVertexAttribArray("t",gl_FLOAT,4,2);initVertexAttribArray("c",gl_UNSIGNED_BYTE,1,4,1);initVertexAttribArray("a",gl_UNSIGNED_BYTE,1,4,1);const sx=2*cameraScale/mainCanvas.width;const sy=2*cameraScale/mainCanvas.height;glContext.uniformMatrix4fv(glContext.getUniformLocation(glShader,"m"),0,new Float32Array([sx,0,0,0,0,sy,0,0,1,1,-1,1,-1-sx*cameraPos.x,-1-sy*cameraPos.y,0,0]))}function glFlush(){if(!glBatchCount)return;const destBlend=glBatchAdditive?gl_ONE:gl_ONE_MINUS_SRC_ALPHA;glContext.blendFuncSeparate(gl_SRC_ALPHA,destBlend,gl_ONE,destBlend);glContext.enable(gl_BLEND);glContext.bufferSubData(gl_ARRAY_BUFFER,0,glPositionData.subarray(0,glBatchCount*gl_VERTICES_PER_QUAD*gl_INDICIES_PER_VERT));glContext.drawArrays(gl_TRIANGLES,0,glBatchCount*gl_VERTICES_PER_QUAD);glBatchCount=0;glBatchAdditive=glAdditive}function glCopyToContext(context,forceDraw){if(!glBatchCount&&!forceDraw)return;glFlush();if(!glOverlay||forceDraw)context.drawImage(glCanvas,0,0)}function glDraw(x,y,sizeX,sizeY,angle,uv0X,uv0Y,uv1X,uv1Y,rgba,rgbaAdditive=0){if(glBatchCount==gl_MAX_BATCH||glBatchAdditive!=glAdditive)glFlush();const c=Math.cos(angle)/2,s=Math.sin(angle)/2;const cx=c*sizeX,cy=c*sizeY,sx=s*sizeX,sy=s*sizeY;for(let i=6,offset=glBatchCount++*gl_VERTICES_PER_QUAD*gl_INDICIES_PER_VERT;i--;){const a=i-4&&i>1,b=i-5&&i-2&&i-1;glPositionData[offset++]=x+(a?-cx:cx)+(b?sy:-sy);glPositionData[offset++]=y+(b?cy:-cy)+(a?sx:-sx);glPositionData[offset++]=a?uv0X:uv1X;glPositionData[offset++]=b?uv0Y:uv1Y;glColorData[offset++]=rgba;glColorData[offset++]=rgbaAdditive}}let glPostShader,glPostArrayBuffer,glPostTexture,glPostIncludeOverlay;function glInitPostProcess(shaderCode,includeOverlay){ASSERT(!glPostShader);if(!shaderCode)shaderCode="void mainImage(out vec4 c,vec2 p){c=texture2D(iChannel0,p/iResolution.xy);}";glPostShader=glCreateProgram("precision highp float;"+"attribute vec2 p;"+"void main(){"+"gl_Position=vec4(p,1,1);"+"}","precision highp float;"+"uniform sampler2D iChannel0;"+"uniform vec3 iResolution;"+"uniform float iTime;"+"\n"+shaderCode+"\n"+"void main(){"+"mainImage(gl_FragColor,gl_FragCoord.xy);"+"gl_FragColor.a=1.;"+"}");glPostArrayBuffer=glContext.createBuffer();glPostTexture=glCreateTexture();glPostIncludeOverlay=includeOverlay;mainCanvas.style.visibility="hidden"}function glRenderPostProcess(){if(!glPostShader)return;if(glEnable){glFlush();mainContext.drawImage(glCanvas,0,0)}else glContext.viewport(0,0,glCanvas.width=mainCanvas.width,glCanvas.height=mainCanvas.height);if(glPostIncludeOverlay){mainContext.drawImage(overlayCanvas,0,0);overlayCanvas.width=mainCanvas.width}glContext.useProgram(glPostShader);glContext.disable(gl_BLEND);glContext.bindBuffer(gl_ARRAY_BUFFER,glPostArrayBuffer);glContext.bufferData(gl_ARRAY_BUFFER,new Float32Array([-3,1,1,-3,1,1]),gl_STATIC_DRAW);glContext.pixelStorei(gl_UNPACK_FLIP_Y_WEBGL,true);glContext.activeTexture(gl_TEXTURE0);glContext.bindTexture(gl_TEXTURE_2D,glPostTexture);glContext.texImage2D(gl_TEXTURE_2D,0,gl_RGBA,gl_RGBA,gl_UNSIGNED_BYTE,mainCanvas);const vertexByteStride=8;const pLocation=glContext.getAttribLocation(glPostShader,"p");glContext.enableVertexAttribArray(pLocation);glContext.vertexAttribPointer(pLocation,2,gl_FLOAT,0,vertexByteStride,0);const uniformLocation=name=>glContext.getUniformLocation(glPostShader,name);glContext.uniform1i(uniformLocation("iChannel0"),0);glContext.uniform1f(uniformLocation("iTime"),time);glContext.uniform3f(uniformLocation("iResolution"),mainCanvas.width,mainCanvas.height,1);glContext.drawArrays(gl_TRIANGLES,0,3)}const gl_ONE=1,gl_TRIANGLES=4,gl_SRC_ALPHA=770,gl_ONE_MINUS_SRC_ALPHA=771,gl_BLEND=3042,gl_TEXTURE_2D=3553,gl_UNSIGNED_BYTE=5121,gl_BYTE=5120,gl_FLOAT=5126,gl_RGBA=6408,gl_NEAREST=9728,gl_LINEAR=9729,gl_TEXTURE_MAG_FILTER=10240,gl_TEXTURE_MIN_FILTER=10241,gl_TEXTURE_WRAP_S=10242,gl_TEXTURE_WRAP_T=10243,gl_COLOR_BUFFER_BIT=16384,gl_CLAMP_TO_EDGE=33071,gl_TEXTURE0=33984,gl_TEXTURE1=33985,gl_ARRAY_BUFFER=34962,gl_STATIC_DRAW=35044,gl_DYNAMIC_DRAW=35048,gl_FRAGMENT_SHADER=35632,gl_VERTEX_SHADER=35633,gl_COMPILE_STATUS=35713,gl_LINK_STATUS=35714,gl_UNPACK_FLIP_Y_WEBGL=37440,gl_VERTICES_PER_QUAD=6,gl_INDICIES_PER_VERT=6,gl_MAX_BATCH=1<<16,gl_VERTEX_BYTE_STRIDE=4*2*2+4*2,gl_VERTEX_BUFFER_SIZE=gl_MAX_BATCH*gl_VERTICES_PER_QUAD*gl_VERTEX_BYTE_STRIDE;